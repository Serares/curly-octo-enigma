// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: questions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createQuestion = `-- name: CreateQuestion :exec
insert into questions (
        id,
        created_at,
        updated_at,
        user_sub,
        user_email,
        user_name,
        upvotes,
        downvotes,
        title,
        body
    )
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateQuestionParams struct {
	ID        string
	CreatedAt time.Time
	UpdatedAt time.Time
	UserSub   string
	UserEmail string
	UserName  string
	Upvotes   int64
	Downvotes int64
	Title     string
	Body      string
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) error {
	_, err := q.db.ExecContext(ctx, createQuestion,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UserSub,
		arg.UserEmail,
		arg.UserName,
		arg.Upvotes,
		arg.Downvotes,
		arg.Title,
		arg.Body,
	)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions
WHERE id = ?
`

func (q *Queries) DeleteQuestion(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteQuestion, id)
	return err
}

const downvoteQuestion = `-- name: DownvoteQuestion :exec
UPDATE questions
SET downvotes = downvotes + 1
WHERE id = ?
`

func (q *Queries) DownvoteQuestion(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, downvoteQuestion, id)
	return err
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, created_at, updated_at, user_sub, user_name, user_email, upvotes, downvotes, title, body
FROM questions
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetQuestion(ctx context.Context, id string) (Question, error) {
	row := q.db.QueryRowContext(ctx, getQuestion, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserSub,
		&i.UserName,
		&i.UserEmail,
		&i.Upvotes,
		&i.Downvotes,
		&i.Title,
		&i.Body,
	)
	return i, err
}

const getQuestionWithAnswers = `-- name: GetQuestionWithAnswers :many
SELECT q.id, q.created_at, q.updated_at, user_sub, user_name, user_email, q.upvotes, q.downvotes, title, body, a.id, question_id, content, a.upvotes, a.downvotes, a.created_at, a.updated_at
FROM questions q
    LEFT JOIN answers a ON q.id = a.question_id
WHERE q.id = ?
ORDER BY a.created_at DESC
`

type GetQuestionWithAnswersRow struct {
	ID          string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	UserSub     string
	UserName    string
	UserEmail   string
	Upvotes     int64
	Downvotes   int64
	Title       string
	Body        string
	ID_2        sql.NullString
	QuestionID  sql.NullString
	Content     sql.NullString
	Upvotes_2   sql.NullInt64
	Downvotes_2 sql.NullInt64
	CreatedAt_2 sql.NullInt64
	UpdatedAt_2 sql.NullInt64
}

func (q *Queries) GetQuestionWithAnswers(ctx context.Context, id string) ([]GetQuestionWithAnswersRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionWithAnswers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuestionWithAnswersRow
	for rows.Next() {
		var i GetQuestionWithAnswersRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserSub,
			&i.UserName,
			&i.UserEmail,
			&i.Upvotes,
			&i.Downvotes,
			&i.Title,
			&i.Body,
			&i.ID_2,
			&i.QuestionID,
			&i.Content,
			&i.Upvotes_2,
			&i.Downvotes_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionWithCountAnswers = `-- name: GetQuestionWithCountAnswers :one
SELECT q.id,
    COUNT(a.id) AS number_of_answers
FROM questions q
    LEFT JOIN answers a ON q.id = a.question_id
WHERE q.id = ?
GROUP BY q.id
`

type GetQuestionWithCountAnswersRow struct {
	ID              string
	NumberOfAnswers int64
}

func (q *Queries) GetQuestionWithCountAnswers(ctx context.Context, id string) (GetQuestionWithCountAnswersRow, error) {
	row := q.db.QueryRowContext(ctx, getQuestionWithCountAnswers, id)
	var i GetQuestionWithCountAnswersRow
	err := row.Scan(&i.ID, &i.NumberOfAnswers)
	return i, err
}

const listQuestions = `-- name: ListQuestions :many
SELECT id, created_at, updated_at, user_sub, user_name, user_email, upvotes, downvotes, title, body
FROM questions
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListQuestionsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListQuestions(ctx context.Context, arg ListQuestionsParams) ([]Question, error) {
	rows, err := q.db.QueryContext(ctx, listQuestions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Question
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserSub,
			&i.UserName,
			&i.UserEmail,
			&i.Upvotes,
			&i.Downvotes,
			&i.Title,
			&i.Body,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :exec
UPDATE questions
SET updated_at = ?,
    title = ?,
    body = ?
WHERE id = ?
    AND user_sub = ?
`

type UpdateQuestionParams struct {
	UpdatedAt time.Time
	Title     string
	Body      string
	ID        string
	UserSub   string
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) error {
	_, err := q.db.ExecContext(ctx, updateQuestion,
		arg.UpdatedAt,
		arg.Title,
		arg.Body,
		arg.ID,
		arg.UserSub,
	)
	return err
}

const upvoteQuestion = `-- name: UpvoteQuestion :exec
UPDATE questions
SET upvotes = upvotes + 1
WHERE id = ?
`

func (q *Queries) UpvoteQuestion(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, upvoteQuestion, id)
	return err
}
